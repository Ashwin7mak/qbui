import com.quickbase.utils.OracleSqlConnectInfo
import com.quickbase.utils.Utils
import java.text.SimpleDateFormat
//
//  MOVE TO Root project FOLDER ONCE gradle-grunt-plugin IS UPDATED TO ALLOW
//  FOR GruntFile.js to be located in a folder other than where the gradle
//  build script is located.
//
//  Next rev of gradle-grunt plugin should include this new functionality
//

description = "Package for Node.js application and UI files"

//******************************************************
// declare the plugins we are going to use
//******************************************************
apply plugin: 'com.moowork.grunt'
apply plugin: 'com.moowork.node'
apply plugin: 'sonar-runner'
apply plugin: 'org.sonarqube'
apply plugin: 'sonarBuildBreak'
apply plugin: 'com.bmuschko.cargo'

//grab the current working directory to use later on
def cwd = project.getProjectDir().absolutePath
//******************************************************
//  Build dependencies...local
//******************************************************
buildscript {
    ext {
        nexusRoot = "https://nexus1.ci.quickbaserocks.com/nexus/content/repositories/"
        nexusUser = "developer"
        nexusPassword = "id2ubV8miEVhXtGd"
        quickbaseVersion = "1.0"
    }
    repositories {
        maven {
            url nexusRoot + "jcenter/"
        }
        maven {
            url nexusRoot + "central/"
        }
        maven {
            url nexusRoot + "gradle2/"
        }
        maven {
            url nexusRoot + "snapshots/"
        }
        flatDir name: 'ExternalJars', dirs: '../lib/plugins'
        dependencies {
            classpath 'com.moowork.gradle:gradle-grunt-plugin:0.9'
            classpath 'com.moowork.gradle:gradle-node-plugin:0.9'
            classpath 'com.bmuschko:gradle-cargo-plugin:2.2.1'
            classpath 'org.sonarqube.gradle:gradle-sonarqube-plugin:1.1'
            classpath 'com.quickbase.gradle:sonar-buildbreak-plugin:0.1.0-SNAPSHOT'
        }
    }
}

dependencies {
    def cargoVersion = '1.4.5'
    cargo "org.codehaus.cargo:cargo-core-uberjar:$cargoVersion",
            "org.codehaus.cargo:cargo-ant:$cargoVersion",
            "commons-discovery:commons-discovery:0.5",
            "commons-logging:commons-logging:1.1.3",
            "dom4j:dom4j:1.6.1",
            "jaxen:jaxen:1.1.6"
}

def cargoHome = "/tmp/cargo";
def extraJvmArgs = ""
def testUser = getTestUser();
def testUserPassword = generateRandomString(16);
def sqlConnectInfo = new OracleSqlConnectInfo("${rootDir}/../quickbase")
def environment = System.getProperty("env");
def awsEnv = (environment == "aws");

// TODO: after moving off of cloud9 and fully into AWS, remove the default values below - QBSE-19121
def salt="salt123";
def anotherSalt="salt456";
def hashkey="*ad023,.SdfW";

def clusterName="TestCluster";
def clusterAddress="224.12.1.0";
def clusterPort=8090;

def cargoHttpPort=8080;
def cargoAjpPort = 9090;
def cargoRmiPort = 8200;

def testURL = "http://localhost:8080/api";
if(System.getProperty("endpoint")) {
    testURL = System.getProperty("endpoint");
}

// Setup Sauce Connection information for try job
def instanceId = System.getenv("INSTANCE_ID");
def executorId = System.getenv("EXECUTOR_NUMBER");
//def sauceURL = "https://localhost."+ instanceId + "-" + executorId + ".slave.ci.quickbaserocks.com";
def sauceURL = "https://localhost:9000";
def sauceKey = System.getenv("SAUCE_KEY");
def sauceJobName = "JENKINS_UI_E2E_" + System.getenv("BUILD_NUMBER");
def tunnelIdentifier = "JENKINS_TUNNEL_E2E_" + System.getenv("BUILD_NUMBER");

// TODO: Pull the code below out into a separate groovy class - QBSE-19142
// If running in AWS, there is no manually created properties file, so the settings must be retrieved using secret-cli
if (awsEnv) {
    // If there is a specific test user, either supplied or needed because using RDS, create the testUser in Oracle.
    if (testUser) {
        logger.lifecycle("Running tests with user " + testUser)
        sqlConnectInfo.createTestUser(testUser, testUserPassword);
    }

    // Get the authorization secrets using the secret CLI
    salt = Utils.executeCmd("${rootDir}/tools/ci/getSecret.sh ticket NewStackTicketHashSalt");
    anotherSalt = Utils.executeCmd("${rootDir}/tools/ci/getSecret.sh ticket NewStackTicketAnotherSalt");
    hashkey = Utils.executeCmd("${rootDir}/tools/ci/getSecret.sh ticket NewStackTicketHashKey");

    extraJvmArgs += " -Dauth.ticket.encryption.salt=\"${salt}\"";
    extraJvmArgs += " -Dauth.ticket.encryption.anothersalt=\"${anotherSalt}\"";
    extraJvmArgs += " -Dauth.ticket.encryption.hashkey=\"${hashkey}\"";

    extraJvmArgs += " -Ducp.sql.url=" + sqlConnectInfo.getConnectUrl();

    // Set the DB credentials
    if (testUser) {
        extraJvmArgs += " -Ducp.sql.user=" + testUser;
        extraJvmArgs += " -Ducp.sql.password=" + testUserPassword;

        clusterName = "TestCluster-${testUser}"
    } else {
        extraJvmArgs += " -Ducp.sql.user=" + sqlConnectInfo.user;
        extraJvmArgs += " -Ducp.sql.password=" + sqlConnectInfo.password;
    }

    // Allow for multiple jobs to be run by dynamically setting cargo port numbers based on the jenkins executor number
    def executorNumber = System.getenv("EXECUTOR_NUMBER");
    if (executorNumber) {
        def iExecutor = Integer.parseInt(executorNumber)
        clusterAddress = "224.12.1." + executorNumber;
        clusterPort = 12100 + iExecutor;

        cargoHttpPort = 8080 + iExecutor;
        cargoAjpPort = 9090 + iExecutor;
        cargoRmiPort = 8200 + iExecutor;

        cargoHome = "/tmp/cargo_" + executorNumber;
    }

    extraJvmArgs += " -Denv=aws";
}

//  CI Builds need the following properties to properly package and archive the build artifacts
println("CI Build: " + isCIBuild() )
if (isCIBuild()) {
    rootProject.ext.allServicePrefix = getServicePrefix() + "_"
    rootProject.ext.CISystemUser = getCiSystemUser()
    rootProject.ext.releasePrefix = getReleasePrefix();
}
rootProject.ext.buildTime = "." + getBuildTime();

println("cwd " + cwd )

println "Checking cargo home directory ${cargoHome}"
if (!file(cargoHome).exists()) {
    println "Creating cargo home directory ${cargoHome}"
    file(cargoHome).mkdir()
    if (!file(cargoHome).exists()) {
        println "Failed to create directory ${cargoHome}"
    }
}

cargo {
    containerId = 'tomcat8x'

    port = 8080

    deployable {
        context = 'api'
        file = file(getAllServicesWar(cwd))
    }

    local {
        timeout=1000000
        logLevel = 'medium'

        homeDir       = file(cargoHome)
        configHomeDir = file(cargoHome)

        containerProperties {
            property 'cargo.servlet.port', cargoHttpPort
            property 'cargo.tomcat.ajp.port', cargoAjpPort
            property 'cargo.rmi.port', cargoRmiPort
        }

        jvmArgs ="-Dspring.profiles.active=default" +
                " -Dtangosol.coherence.override=${getCommonCoherenceResources(cwd)}/tangosol-coherence-override-test.xml" +
                " -Dquickbase.coherence.cluster=${clusterName}" +
                " -Dtangosol.coherence.clusteraddress=${clusterAddress}" +
                " -Dtangosol.coherence.clusterport=${clusterPort}" +
                " -Dtangosol.pof.enabled=true" +
                " -Dtangosol.pof.config=${getCommonCoherenceResources(cwd)}/quickbase-pof-config.xml" + extraJvmArgs

        installer {
            installUrl = "file://" + cwd + "/../tools/ci/apache-tomcat-8.0.20.zip"
            downloadDir = file("$buildDir/download")
            extractDir = file("$buildDir/extract")
            outputFile = file("$buildDir/tomcat.log")
        }
    }
}


node {
    // Version of node to use.
    //version = '0.10.31'
    version = '4.2.3'

    npmVersion = '2.14.10'
    // Base URL for fetching node distributions (change if you have a mirror).
    //distBaseUrl = 'http://nodejs.org/dist'
    // full URL is http://nodejs.org/dist/v0.10.31/node-v0.10.31-darwin-x64.tar.gz

    // We use the local Cloud9 repository the file URL will be
    // http://pppdc9prd0t4:8081/nexus/service/local/repositories/phoenix/content/nodejs/node/v0.10.31/node-v0.10.31-darwin-x64.tar
    // to update the file, upload a new node.js binary for each supported OS in Nexus with:
    // group: nodejs
    // artifact: node
    // version: v0.10.35  // put in the new version
    // packaging: gz
    // filename:  (filled in by upload)
    // classifier: darwin-x64  // use whatever is in that section of the original file name for the OS
    // extension: gz

    //distBaseUrl = 'http://pppdc9prd0t4:8081/nexus/service/local/repositories/phoenix/content/nodejs/node'
    distBaseUrl = 'http://nodejs.org/dist'


    // Download node if running a CI build; otherwise use globally installed node.
    download = isCIBuild()

    // Set the work directory for unpacking node...can't be under build directory as the clean task will wipe out the directory
    workDir = file("$projectDir/nodejs")

}

//******************************************************
//  Gradle tasks
//******************************************************

task zip(type: Zip) {

    archiveName = getProjectArchive()
    destinationDir = file("$buildDir/distributions/")

    from ('dist') {
        into('dist')
    }
}

zip.doFirst {
    println( "Assembling: " + getProjectArchive() )
    println( "Branch : " + getProjectArchive() )
}

task clean_node_modules(type: Delete) {
    delete 'dist/node_modules'
}

npm_install {
    args = ['--verbose']
}

task npmCacheClean (type: NpmTask) {
    args = ["cache", "clean", "--verbose"]
}
task npmInstallVerbose(type: NpmTask) {
    args = ['install', '--verbose', '--debug' ]
}

task npmInstallLean(type: NpmTask) {
    args = ['install']
}

task npmListConfig(type: NpmTask) {
    args = ['config', 'ls', '-l' ]
}

task npmPrune(type: NpmTask) {
    args = ['prune']
}

task npmPruneProduction (type: NpmTask) {
    args = ['prune', '--production']
    execOverrides {
        it.workingDir = cwd + "/dist"
    }
}

task npmUpdateWebdriver(type: NpmTask) {
    args = ['run', 'update-webdriver']
}

task npmInstallProduction (type: NpmTask) {
    args = ['install', '--production']
    execOverrides {
        it.workingDir = cwd + "/dist"
    }
}

task dumpSys <<{
    println "System Properties:"
    System.properties.each {
        println "   $it"
    }
}

task dumpProj<< {
    println "Project Properties:"
    project.properties.each { key, value ->
        if (!key.equals("plugins") && !key.equals("tasks") && !key.equals("properties"))
            println "   $key=$value" }
}

task dumpPlugins <<{
    println "Plugin Properties:"
    project.plugins.each {
        println "    plugin: $it"
        it.properties.each {
            println "       $it"
        }
    }
}

task dumpEnv <<{
     dumpSys
     dumpProj
     dumpPlugins
}

task npmRebuildJpegtran (type: NpmTask) {
    args =['rebuild', 'jpegtran-bin']
}

task npmRebuildNodeSass (type: NpmTask) {
    args =['rebuild', 'node-sass']
}

task npmInstallReactRouter (type: NpmTask) {
    args = [ 'install', 'react-router@1.0.0-rc3']
}

task npmRmJpegtran (type: NpmTask) {
    args = ['rm', 'jpegtran-bin']
}

task npmInstallJpegtran (type: NpmTask) {
    args = [ 'install', 'jpegtran-bin@0.1.0']
}

task gruntBuildDebugVerbose(type: GruntTask) {
    args = ["build",  "--no-color", "--debug", "--verbose", "--stacktrace"]
}

task gruntTestDebugVerbose(type: GruntTask) {
    args = ["ciTest", "--no-color", "--debug", "--verbose", "--stacktrace"]
}

task gruntSassDebugVerbose(type: GruntTask) {
    args = ["sass", "--debug", "--verbose", "--no-color"]
}

task gruntBuildNoColor(type: GruntTask) {
    args = ["build", "--no-color"]
}

task gruntUnitTestsNoColor(type: GruntTask) {
    args = ["ciTest", "--no-color"]
}

task startTomcat {
    doFirst {
        println("Starting Tomcat instance with Cargo");
        println( "Deploying war: ${getAllServicesWar(cwd)}")
        println( "Cargo output log folder: $buildDir")
        tasks.cargoStartLocal.execute()
    }
}
task stopTomcat {
    doFirst {
        println("Stopping Tomcat instance with Cargo");
        tasks.cargoStopLocal.execute()
    }
}

task invokeInstallSauceLabs(type:Exec) {
    executable cwd + "/../tools/aws/jenkins_install_sauce.sh"
}

task invokeCheckForApiUp(type:Exec) {
    executable cwd + "/../tools/ci/checkForApiUp.sh"
    args '60', testURL
}

task checkForApiUp() {
    doFirst {
        tasks.invokeCheckForApiUp.execute()
    }
    dependsOn startTomcat
    finalizedBy stopTomcat
}

task integrationTestsNoColor(type: GruntTask) {
    doFirst {
        tasks.invokeCheckForApiUp.execute()
        args = ["ciIntegration", "--no-color"]
    }
    dependsOn startTomcat
    finalizedBy stopTomcat
}

//browser tests not yet supported on ci
task gruntCiE2ETestsNoColor(type: GruntTask) {
    doFirst {
        tasks.invokeCheckForApiUp.execute()
        args = ["test:e2e", "--no-color"]
    }
    dependsOn startTomcat
    finalizedBy stopTomcat
}

//browser tests in AWS
task gruntE2EAWSSauce(type: GruntTask) {
    doFirst {
        tasks.invokeInstallSauceLabs.execute()
        tasks.invokeCheckForApiUp.execute()
        args = ["test:e2eAWSSauce", "--baseUrl", sauceURL, "--sauceKey", sauceKey, "--sauceJobName", sauceJobName, "--tunnelIdentifier", tunnelIdentifier]
    }
    dependsOn startTomcat
    finalizedBy stopTomcat
}

task cleanBuildDir (type: Delete) {
    delete 'build'
}

task deleteDistModules(type: Delete) {
    delete "dist/node_modules"
}

task installExpress(type: NpmTask) {
    // install the express package only
    args = ['install', 'express', '--save-dev']
}

//******************************************************
//  Define task dependencies
//******************************************************

zip.dependsOn clean, npmInstallProduction
build.dependsOn clean, grunt_build
clean.dependsOn grunt_clean, cleanBuildDir
test.dependsOn clean, gruntUnitTestsNoColor
npmInstallProduction.dependsOn grunt_build, dumpSys


// the directory for nightly builds used to release from
project.group = "build_rpms"
artifacts {
    archives file: file("build/distributions/" + getProjectArchive()),
        name: "${project.name}",
        type: "zip",
        builtBy: zip
}

def ivyPasswd = System.getProperty("ivyPasswd", "");         // The IVY password for the Nexus repository
def ivyUser = System.getProperty("ivyUser", "qbbuilds");     // By default use the qbbuilds user, password needs to be provided
def paramBranch =  System.getProperty("GIT_BRANCH", "");

/*
 Push the zip file with the build to the Nexus Repository.
 The repo is located at
http://pppdc9prd0t4:8081/nexus/index.html#welcome

username is admin
pw -- ask OPS or Agave

The zips go to the Phoenix repository under QuickBase/ui/ if they are versioned, and to the Snapshots repository if
they are not versioned.

 */
uploadArchives {
    def uploadUrl = "https://nexus1.ci.quickbaserocks.com/nexus/content/repositories/"
    def layoutStr = "[organisation]/[module]/[revision]/[artifact]-[revision](.[ext])"
    // release archives vs dev  have different archive path on repo server dev builds go to nonrelease snapshot dir
    // repo server policy for snapshots(update-able rpms) cannot live on release repo dirs
    // organisation - Project.getGroup(): build_rpms
    // module - Project.getName(): ui
    // revision - Project.getVersion(): phoenix-1.0
    if (isCIBuild()) {
        uploadUrl += "/phoenix/"
        layoutStr = getArchiveLayoutStr(false)
    } else {
        uploadUrl += "/snapshots/"
        layoutStr = getArchiveLayoutStr(true)
    }
    repositories {
        ivy {
            credentials {
                username "${ivyUser}"
                password "${ivyPasswd}"
            }
            url "${uploadUrl}"
            layout 'pattern' , {
                artifact "${layoutStr}"
            }
        }
    }
}


//******************************************************
// Sonar task that performs coverage and analysis of the ui project
//******************************************************

sonarRunner {
    //Resolve the executing user's name
    def user = System.getProperty("user.name")
    //Resolve the branch name
    def proc = "git rev-parse --abbrev-ref HEAD".execute()
    proc.waitFor()
    def branchName = proc.in.text.replace("\n", "").replace("\r", "").trim()
    def gitBranch = branchName;
    println 'gitBranch:' + gitBranch;

    if (paramBranch) {
        println 'paramBranch:' + paramBranch;
        branchName = paramBranch;
    }
    //Resolve the git revision
    def procrev = "git rev-parse  HEAD".execute()
    procrev.waitFor()
    def gitRevision = procrev.in.text.replace("\n", "").replace("\r", "").trim()
    println 'gitRevision:' + gitRevision;

    sonarProperties{
        // the user name becomes part of the project key, this way Jenkins builds are separated from the commoners, meaning you...
        // for UI we analyse the react client and the nodejs server as 2 modules
        // see: http://docs.codehaus.org/display/SONAR/Analyzing+with+SonarQube+Runner#AnalyzingwithSonarQubeRunner-Multi-moduleProject
        property "sonar.projectKey", "ui:${branchName}:${user}"
        property "sonar.projectVersion", "0.1"
        property "sonar.projectName", "${user}:ui:${branchName}"
        property "sonar.qualitygate", "Sonar%20way%20with%20Findbugs%20-%20reactjs"
        property "sonar.host.url", "http://pppdc9prd01j:9000/"
        property "sonar.jdbc.url", "jdbc:mysql://pppdc9prd01j:3306/sonar?autoReconnect=true&useUnicode=true&characterEncoding=utf8"
        property "sonar.language", "js"
        property "sonar.jdbc.username", "sonar"
        property "sonar.jdbc.password", "sonar"
        property "sonar.sources", "."
        property "sonar.modules", "client-react,server"
        property "sonar.coverage.exclusions", "**/*.spec.js"
        property "client-react.sonar.projectName", "${user}:ui:${branchName}:client"
        property "client-react.sonar.sources", "$projectDir/client-react/src"
        property "client-react.sonar.exclusions", "**/assets/**,**/constants/**,**/locales/bundles/**"

        //  import the ui LCOV coverage report
        property "client-react.sonar.javascript.lcov.reportPath","${projectDir}/build/reports/client/coverage/lcov.info"

        property "server.sonar.projectName", "${user}:ui:${branchName}:server"
        property "server.sonar.sources", "$projectDir/server"
        property "server.sonar.exclusions", "**/test/**,**/config/environment/**,**/mockserver/**"
        //  import the ui LCOV coverage report
        property "server.sonar.javascript.lcov.reportPath","${projectDir}/build/reports/server/coverage/lcov.info"

        // Can be added back in for debugging purposes
        //property "sonar.verbose", "true"
    }
}

// sonarRunner is being depricated and sonarqube is the replacement
sonarqube {
    //Resolve the executing user's name
    def user = System.getProperty("user.name")
    //Resolve the branch name
    def proc = "git rev-parse --abbrev-ref HEAD".execute()
    proc.waitFor()
    def branchName = proc.in.text.replace("\n", "").replace("\r", "").trim()
    println 'branchName:' + branchName;

    if (paramBranch) {
        println 'paramBranch:' + paramBranch;
        branchName = paramBranch;
    }

    properties {
        // the user name becomes part of the project key, this way Jenkins builds are separated from the commoners, meaning you...
        property "sonar.projectKey", "ui:${branchName}:${user}"
        property "sonar.projectVersion", "0.1"
        property "sonar.projectName", "${user}:ui:${branchName}"
        //property "sonar.qualitygate", "Sonar%20way%20with%20Findbugs%20-%20reactjs"
        property "sonar.host.url", "https://sonar1.ci.quickbaserocks.com/"
        property "sonar.login", "quickbase"
        property "sonar.password", "blue"
        property "sonar.sources", "."
        property "sonar.modules", "client-react,server"
        property "sonar.coverage.exclusions", "**/*.spec.js"
        property "client-react.sonar.projectName", "${user}:ui:${branchName}:client"
        property "client-react.sonar.sources", "${projectDir}/client-react/src"
        property "client-react.sonar.exclusions", "**/assets/**,**/constants/**,**/locales/bundles/**"

        //  import the ui LCOV coverage report
        property "client-react.sonar.javascript.lcov.reportPath","${projectDir}/build/reports/client/coverage/lcov.info"

        property "server.sonar.projectName", "${user}:ui:${branchName}:server"
        property "server.sonar.sources", "${projectDir}/server"
        property "server.sonar.exclusions", "**/test/**,**/config/environment/**,**/mockserver/**"
        //  import the ui LCOV coverage report
        property "server.sonar.javascript.lcov.reportPath","${projectDir}/build/reports/server/coverage/lcov.info"

        // Can be added back in for debugging purposes
        //property "sonar.verbose", "true"
    }
}

//******************************************************
//  Supporting Groovy functions
//******************************************************
def getRpmVersion() {
    return "1.0"
}
def getServicePrefix() {
    return "phoenix"
}
def getCiSystemUser() {
    return "jenkins"
}

def getReleasePrefix() {
    def prefix = getServicePrefix()
    def ciUser = getCiSystemUser()
    def user = System.getProperty("user.name");

    //dev builds get user info for rpm war etc
    if (!user.equals(ciUser) && isReleaseSnapshot()) {
        prefix += "_${user}"
    }
    return prefix
}

def getProjectArchive() {
    return "${project.name}-${getReleasePrefix()}_${getRpmVersion()}-${getRelease()}.zip"
}

def getArchiveLayoutStr(useBuildTime) {
    def base = "[organisation]/[module]/[revision]/[artifact]-${getReleasePrefix()}_${getRpmVersion()}"
    if (useBuildTime) {
        base += getBuildTime()
    } else {
        base += "-${getRelease()}"
    }
    return "${base}(.[ext])"
}

def getBuildTime() {
    def df = new SimpleDateFormat("yyyyMMdd:HHmmss")
    df.setTimeZone(TimeZone.getTimeZone("UTC"))
    return df.format(new Date())
}

def getRelease() {
    return System.getProperty("releaseNumber", "SNAPSHOT")
}

def isReleaseSnapshot() {
    return getRelease().equals("SNAPSHOT")
}

def isCIBuild() {
    return getReleasePrefix().equals(getServicePrefix())
}

//  TODO: the following methods are temporary as we ultimately want to retrieve the war from a nexus repository and not have to build
//  TODO: it from the QuickBase folder structure on every CI run.  When a nexus repo is updated to include the latest war, this
//  TODO: code should be refactored to pull from nexus and the CI build configuration task that builds the war should be deleted.
//
//  return the folder where the allServices war is located
def getAllServicesWar(cwd) {
    return "${cwd}/../../quickbase/allServices/build/libs/allServices-${getReleasePrefix()}_${getRpmVersion()}-${getRelease()}.war"
}
//  return the folder where the coherenceCommon resources are located
def getCommonCoherenceResources(cwd) {
    return "${cwd}/../../quickbase/coherenceCommon/src/main/resources"
}
